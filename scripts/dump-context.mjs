import { spawnSync } from 'node:child_process';
import { createHash } from 'node:crypto';
import { mkdir, readdir, readFile, writeFile } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const ROOT_DIR = path.resolve(fileURLToPath(new URL('..', import.meta.url)));
const REPO_INDEX_RELATIVE_PATH = 'docs/REPO_INDEX.md';
const REPO_INDEX_SHA_RELATIVE_PATH = 'docs/REPO_INDEX.md.sha256';
const EXCLUDED_DIRECTORIES = new Set(['.git', 'node_modules']);
const MAX_REPO_INDEX_BYTES = 250 * 1024;
const UTF8_DECODER = new TextDecoder('utf-8', { fatal: true });
const POLICY_FILES = new Set(['AGENTS.md', 'CONTRIBUTING.md', 'SECURITY.md']);
const SPEC_FILES = new Set(['SPEC.md']);
const DOC_FILES = new Set(['ARCHITECTURE.md', 'CHANGELOG.md', 'README.md', 'LICENSE']);
const CONFIG_BASENAMES = new Set([
  'package.json',
  'jsr.json',
  'repo.manifest.yaml',
  'repo.manifest.yml',
  'tsconfig.json',
  'tsconfig.test.json',
  'eslint.config.js',
  '.gitignore'
]);
const ERROR_CODE_PATTERNS = [
  /\b(?:type|interface|enum)\s+[A-Za-z0-9_]*ErrorCode\b/u,
  /\b[A-Za-z0-9_]*ErrorCode\b/u
];

if (isEntrypoint()) {
  await runCli();
}

/**
 * @param {string} [rootDir]
 * @returns {Promise<string>}
 */
export async function generateRepoIndexMarkdown(rootDir = ROOT_DIR) {
  const state = await collectRepositoryState(rootDir);
  const packageJson = await readJsonIfPresent(path.join(rootDir, 'package.json'));
  const jsrJson = await readJsonIfPresent(path.join(rootDir, 'jsr.json'));
  const gitIdentity = readGitIdentity(rootDir);
  const tree = renderTree(state.files, state.directories);
  const inventory = renderInventoryTable(state.entries);
  const contractSummary = renderContractSurfaceSummary(state.entries, packageJson, jsrJson);

  const lines = [
    '---',
    'role: index',
    'audience: maintainers, agents',
    `source_of_truth: ${REPO_INDEX_RELATIVE_PATH}`,
    'update_triggers:',
    '  - file additions, removals, or renames',
    '  - file content changes',
    '  - export, schema, or error-surface changes',
    '---',
    '',
    '# Repository Index',
    '',
    'Generated by `scripts/dump-context.mjs` via `npm run context:index`.',
    'Scope includes working-tree files and excludes `.git/`, `node_modules/`, `docs/REPO_INDEX.md` (self-reference), and `docs/REPO_INDEX.md.sha256` (self-hash).',
    '',
    '## Git Identity',
    '',
    `- HEAD: \`${gitIdentity.head}\``,
    '- Status (`git status --short --branch`):',
    '```text',
    gitIdentity.status,
    '```',
    '',
    '## Full File Tree',
    '',
    `- total_files: ${state.files.length}`,
    `- total_directories: ${Math.max(0, state.directories.size - 1)}`,
    '',
    '```text',
    tree,
    '```',
    '',
    '## Per-File Inventory',
    '',
    inventory,
    '',
    '## Contract Surface Summary',
    '',
    contractSummary
  ];

  return `${lines.join('\n')}\n`;
}

/**
 * @param {string} [rootDir]
 * @returns {Promise<{ bytes: number; path: string }>}
 */
export async function writeRepositoryIndex(rootDir = ROOT_DIR) {
  const markdown = await generateRepoIndexMarkdown(rootDir);
  const bytes = Buffer.byteLength(markdown, 'utf8');
  if (bytes > MAX_REPO_INDEX_BYTES) {
    throw new Error(
      `docs/REPO_INDEX.md exceeds ${MAX_REPO_INDEX_BYTES} bytes (${bytes}); reduce index noise`
    );
  }

  await writeMarkdownWithSha256(rootDir, REPO_INDEX_RELATIVE_PATH, markdown);
  return { bytes, path: REPO_INDEX_RELATIVE_PATH };
}

async function runCli() {
  const args = process.argv.slice(2);
  if (args.length === 0 || (args.length === 1 && args[0] === '--index')) {
    await writeRepositoryIndex(ROOT_DIR);
    return;
  }

  throw new Error(['Usage:', '  npm run context:index'].join('\n'));
}

/**
 * @param {string} rootDir
 * @returns {Promise<{ files: string[]; directories: Set<string>; entries: Array<{ path: string; bytes: number; sha256: string; kind: 'text' | 'binary'; role: string; errorSurface: boolean }> }>}
 */
async function collectRepositoryState(rootDir) {
  const directories = new Set(['']);
  const files = [];
  await walkDirectory(rootDir, '', files, directories);
  files.sort(compareLexicographic);

  const entries = [];
  for (const relativePath of files) {
    const absolutePath = path.join(rootDir, ...relativePath.split('/'));
    const bytes = await readFile(absolutePath);
    const sha256 = createHash('sha256').update(bytes).digest('hex');
    const decoded = decodeText(bytes);
    const kind = decoded === null ? 'binary' : 'text';
    const role = classifyRole(relativePath);
    const errorSurface =
      decoded !== null &&
      relativePath.startsWith('src/') &&
      relativePath.endsWith('.ts') &&
      isErrorSurface(relativePath, decoded);

    entries.push({
      path: relativePath,
      bytes: bytes.byteLength,
      sha256,
      kind,
      role,
      errorSurface
    });
  }

  return {
    files,
    directories,
    entries
  };
}

/**
 * @param {string} absoluteDir
 * @param {string} relativeDir
 * @param {string[]} files
 * @param {Set<string>} directories
 * @returns {Promise<void>}
 */
async function walkDirectory(absoluteDir, relativeDir, files, directories) {
  const dirEntries = await readdir(absoluteDir, { withFileTypes: true });
  dirEntries.sort((a, b) => compareLexicographic(a.name, b.name));

  for (const entry of dirEntries) {
    const relativePath = relativeDir ? `${relativeDir}/${entry.name}` : entry.name;

    if (entry.isDirectory()) {
      if (shouldSkipDirectory(relativePath)) {
        continue;
      }
      directories.add(relativePath);
      await walkDirectory(path.join(absoluteDir, entry.name), relativePath, files, directories);
      continue;
    }

    if (!entry.isFile() && !entry.isSymbolicLink()) {
      continue;
    }

    if (shouldSkipFile(relativePath)) {
      continue;
    }

    files.push(relativePath);
  }
}

/**
 * @param {readonly string[]} files
 * @param {Set<string>} directories
 * @returns {string}
 */
function renderTree(files, directories) {
  const children = new Map();
  for (const directory of directories) {
    children.set(directory, []);
  }

  for (const directory of directories) {
    if (directory.length === 0) continue;
    const parent = parentPath(directory);
    const collection = children.get(parent);
    if (!collection) {
      throw new Error(`missing parent directory for ${directory}`);
    }

    collection.push({
      type: 'directory',
      name: baseName(directory),
      path: directory
    });
  }

  for (const file of files) {
    const parent = parentPath(file);
    const collection = children.get(parent);
    if (!collection) {
      throw new Error(`missing parent directory for file ${file}`);
    }

    collection.push({
      type: 'file',
      name: baseName(file),
      path: file
    });
  }

  for (const list of children.values()) {
    list.sort(compareTreeNodes);
  }

  const lines = ['.'];
  appendTreeLines('', '', children, lines);
  return lines.join('\n');
}

/**
 * @param {string} directory
 * @param {string} prefix
 * @param {Map<string, Array<{ type: 'directory' | 'file'; name: string; path: string }>>} children
 * @param {string[]} lines
 */
function appendTreeLines(directory, prefix, children, lines) {
  const entries = children.get(directory) ?? [];
  for (let index = 0; index < entries.length; index += 1) {
    const entry = entries[index];
    const isLast = index === entries.length - 1;
    const connector = isLast ? '└── ' : '├── ';
    const suffix = entry.type === 'directory' ? '/' : '';
    lines.push(`${prefix}${connector}${entry.name}${suffix}`);

    if (entry.type === 'directory') {
      const nextPrefix = `${prefix}${isLast ? '    ' : '│   '}`;
      appendTreeLines(entry.path, nextPrefix, children, lines);
    }
  }
}

/**
 * @param {{ type: 'directory' | 'file'; name: string }} a
 * @param {{ type: 'directory' | 'file'; name: string }} b
 * @returns {number}
 */
function compareTreeNodes(a, b) {
  if (a.type !== b.type) {
    return a.type === 'directory' ? -1 : 1;
  }
  return compareLexicographic(a.name, b.name);
}

/**
 * @param {readonly { path: string; bytes: number; sha256: string; kind: string; role: string }[]} entries
 * @returns {string}
 */
function renderInventoryTable(entries) {
  const lines = [
    '| path | bytes | sha256 | kind | role |',
    '| --- | ---: | --- | --- | --- |'
  ];

  for (const entry of entries) {
    lines.push(`| ${entry.path} | ${entry.bytes} | ${entry.sha256} | ${entry.kind} | ${entry.role} |`);
  }

  return lines.join('\n');
}

/**
 * @param {readonly { path: string; bytes: number; sha256: string; kind: string; role: string; errorSurface: boolean }[]} entries
 * @param {Record<string, unknown> | null} packageJson
 * @param {Record<string, unknown> | null} jsrJson
 * @returns {string}
 */
function renderContractSurfaceSummary(entries, packageJson, jsrJson) {
  const packageEntrypoints = renderEntrypoints('npm exports (`package.json`)', packageJson);
  const jsrEntrypoints = renderEntrypoints('jsr exports (`jsr.json`)', jsrJson);

  const schemaFilenames = entries
    .filter((entry) => entry.path.startsWith('schemas/') && path.extname(entry.path) === '.json')
    .map((entry) => path.posix.basename(entry.path))
    .sort(compareLexicographic);

  const errorSurfaceFiles = entries
    .filter((entry) => entry.path.startsWith('src/') && entry.path.endsWith('.ts'))
    .filter((entry) => entry.errorSurface || entry.path.endsWith('/errors.ts') || entry.path.includes('Error'))
    .map((entry) => entry.path)
    .sort(compareLexicographic);

  const checkPipeline = readOneCommandTruth(packageJson);

  const lines = [
    '### Public Entrypoints',
    '',
    ...packageEntrypoints,
    '',
    ...jsrEntrypoints,
    '',
    '### JSON Schemas (`schemas/`)',
    ''
  ];

  if (schemaFilenames.length === 0) {
    lines.push('- none');
  } else {
    for (const file of schemaFilenames) {
      lines.push(`- \`${file}\``);
    }
  }

  lines.push('', '### Error Code Definition Files', '');

  if (errorSurfaceFiles.length === 0) {
    lines.push('- none');
  } else {
    for (const file of errorSurfaceFiles) {
      lines.push(`- \`${file}\``);
    }
  }

  lines.push('', '### One-Command Truth', '', `- \`npm run check\`: \`${checkPipeline}\``);
  return lines.join('\n');
}

/**
 * @param {string} heading
 * @param {Record<string, unknown> | null} json
 * @returns {string[]}
 */
function renderEntrypoints(heading, json) {
  const lines = [`#### ${heading}`, ''];

  if (!json || typeof json !== 'object') {
    lines.push('- unavailable');
    return lines;
  }

  const exportsValue = json.exports;
  if (!exportsValue || typeof exportsValue !== 'object' || Array.isArray(exportsValue)) {
    lines.push('- none');
    return lines;
  }

  const entries = Object.entries(exportsValue).sort(([a], [b]) => compareLexicographic(a, b));
  if (entries.length === 0) {
    lines.push('- none');
    return lines;
  }

  for (const [key, value] of entries) {
    if (typeof value === 'string') {
      lines.push(`- \`${key}\` -> \`${value}\``);
      continue;
    }

    if (!value || typeof value !== 'object' || Array.isArray(value)) {
      lines.push(`- \`${key}\` -> \`${JSON.stringify(value)}\``);
      continue;
    }

    const fields = Object.entries(value)
      .sort(([a], [b]) => compareLexicographic(a, b))
      .map(([field, fieldValue]) => `${field}=\`${String(fieldValue)}\``)
      .join(', ');

    lines.push(`- \`${key}\`: ${fields}`);
  }

  return lines;
}

/**
 * @param {string} rootDir
 * @returns {{ head: string; status: string }}
 */
function readGitIdentity(rootDir) {
  const headProcess = spawnSync('git', ['rev-parse', 'HEAD'], {
    cwd: rootDir,
    encoding: 'utf8'
  });

  const statusProcess = spawnSync('git', ['status', '--short', '--branch'], {
    cwd: rootDir,
    encoding: 'utf8'
  });

  const head = headProcess.status === 0 ? headProcess.stdout.trim() : 'UNKNOWN';
  const status = statusProcess.status === 0 ? normalizeLineEndings(statusProcess.stdout).trimEnd() : 'UNKNOWN';

  return {
    head,
    status: status.length === 0 ? '(clean)' : status
  };
}

/**
 * @param {Record<string, unknown> | null} packageJson
 * @returns {string}
 */
function readOneCommandTruth(packageJson) {
  if (!packageJson || typeof packageJson !== 'object') {
    return 'UNKNOWN';
  }

  const scripts = packageJson.scripts;
  if (!scripts || typeof scripts !== 'object') {
    return 'UNKNOWN';
  }

  return typeof scripts.check === 'string' ? scripts.check : 'UNKNOWN';
}

/**
 * @param {string} relativePath
 * @returns {boolean}
 */
function shouldSkipFile(relativePath) {
  if (shouldSkipDirectory(relativePath)) return true;
  return relativePath === REPO_INDEX_RELATIVE_PATH || relativePath === REPO_INDEX_SHA_RELATIVE_PATH;
}

/**
 * @param {string} relativePath
 * @returns {boolean}
 */
function shouldSkipDirectory(relativePath) {
  const parts = relativePath.split('/');
  return parts.some((part) => EXCLUDED_DIRECTORIES.has(part));
}

/**
 * @param {string} relativePath
 * @returns {string}
 */
function classifyRole(relativePath) {
  const basename = path.posix.basename(relativePath);

  if (relativePath.startsWith('.github/workflows/')) return 'workflow';
  if (relativePath.startsWith('schemas/')) return 'schema';
  if (relativePath.startsWith('scripts/')) return 'script';
  if (relativePath.startsWith('test/fixtures/')) return 'fixture';
  if (relativePath.startsWith('test/')) return 'test';
  if (SPEC_FILES.has(basename) || relativePath.startsWith('specs/')) return 'spec';
  if (POLICY_FILES.has(basename)) return 'policy';

  if (
    relativePath.startsWith('src/') ||
    relativePath === 'mod.ts' ||
    relativePath.endsWith('/mod.ts') ||
    relativePath.endsWith('.ts')
  ) {
    return 'code';
  }

  if (relativePath.startsWith('docs/') || DOC_FILES.has(basename)) return 'doc';

  if (
    CONFIG_BASENAMES.has(basename) ||
    basename.startsWith('.eslintrc') ||
    basename.endsWith('.config.js') ||
    basename.endsWith('.config.cjs') ||
    basename.endsWith('.config.mjs') ||
    basename.endsWith('.yaml') ||
    basename.endsWith('.yml')
  ) {
    return 'config';
  }

  return 'other';
}

/**
 * @param {string} relativePath
 * @param {string} text
 * @returns {boolean}
 */
function isErrorSurface(relativePath, text) {
  if (relativePath.endsWith('/errors.ts')) return true;
  if (relativePath === 'src/errors.ts') return true;
  if (relativePath.includes('Error')) return true;
  return ERROR_CODE_PATTERNS.some((pattern) => pattern.test(text));
}

/**
 * @param {Buffer} bytes
 * @returns {string | null}
 */
function decodeText(bytes) {
  if (bytes.includes(0)) return null;
  try {
    UTF8_DECODER.decode(bytes);
  } catch {
    return null;
  }
  return normalizeLineEndings(bytes.toString('utf8'));
}

/**
 * @param {string} value
 * @returns {string}
 */
function normalizeLineEndings(value) {
  return value.replace(/\r\n/g, '\n');
}

/**
 * @param {string} rootDir
 * @param {string} outputPath
 * @param {string} content
 * @returns {Promise<void>}
 */
async function writeMarkdownWithSha256(rootDir, outputPath, content) {
  const absolutePath = path.join(rootDir, ...outputPath.split('/'));
  await mkdir(path.dirname(absolutePath), { recursive: true });
  await writeFile(absolutePath, content, 'utf8');

  const sha256 = createHash('sha256').update(content, 'utf8').digest('hex');
  const shaContent = `${sha256}  ${path.basename(outputPath)}\n`;
  await writeFile(`${absolutePath}.sha256`, shaContent, 'utf8');
}

/**
 * @param {string} absolutePath
 * @returns {Promise<Record<string, unknown> | null>}
 */
async function readJsonIfPresent(absolutePath) {
  try {
    const text = await readFile(absolutePath, 'utf8');
    const parsed = JSON.parse(text);
    return parsed && typeof parsed === 'object' ? parsed : null;
  } catch (error) {
    if (isErrorCode(error, 'ENOENT')) {
      return null;
    }
    throw error;
  }
}

/**
 * @param {unknown} value
 * @param {string} expected
 * @returns {boolean}
 */
function isErrorCode(value, expected) {
  return (
    Boolean(value) &&
    typeof value === 'object' &&
    'code' in value &&
    typeof value.code === 'string' &&
    value.code === expected
  );
}

/**
 * @param {string} relativePath
 * @returns {string}
 */
function baseName(relativePath) {
  const parts = relativePath.split('/');
  return parts[parts.length - 1] ?? relativePath;
}

/**
 * @param {string} relativePath
 * @returns {string}
 */
function parentPath(relativePath) {
  const index = relativePath.lastIndexOf('/');
  return index === -1 ? '' : relativePath.slice(0, index);
}

/**
 * @returns {boolean}
 */
function isEntrypoint() {
  if (process.argv.length < 2) return false;
  const scriptPath = path.resolve(process.argv[1]);
  return scriptPath === fileURLToPath(import.meta.url);
}

/**
 * @param {string} a
 * @param {string} b
 * @returns {number}
 */
function compareLexicographic(a, b) {
  if (a === b) return 0;
  return a < b ? -1 : 1;
}
